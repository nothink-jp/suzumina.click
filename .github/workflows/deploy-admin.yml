name: Deploy Admin App to Cloud Run

on:
  push:
    branches:
      - main
    paths:
      - 'apps/admin/**'
      - 'packages/**'
      - '.github/workflows/deploy-admin.yml'
  
  # Manual triggering
  workflow_dispatch:

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  REGION: asia-northeast1
  SERVICE_NAME: suzumina-admin
  REPOSITORY: suzumina-click
  IMAGE_NAME: suzumina-admin

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    permissions:
      contents: read
      id-token: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Enable Corepack
        run: corepack enable
      
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          run_install: false
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'pnpm'
      
      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV
      
      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-
      
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
      
      - name: Build shared types
        run: pnpm --filter @suzumina.click/shared-types build
      
      - name: Build UI components
        run: pnpm --filter @suzumina.click/ui build
      
      - name: Run admin app tests
        run: pnpm --filter @suzumina.click/admin test || echo "No tests configured for admin app"
      
      - name: Run admin app linting
        run: pnpm --filter @suzumina.click/admin lint
      
      - name: Run admin app type checking
        run: pnpm --filter @suzumina.click/admin typecheck
      
      # Google Cloud authentication
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: 'projects/${{ secrets.GCP_PROJECT_NUMBER }}/locations/global/workloadIdentityPools/github-pool/providers/github-provider'
          service_account: 'github-actions-sa@${{ secrets.GCP_PROJECT_ID }}.iam.gserviceaccount.com'
      
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}
      
      - name: Configure Docker to use gcloud as a credential helper
        run: |
          gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev
      
      # Build and push Docker image
      - name: Build and push Docker image
        run: |
          # Generate image tag
          IMAGE_TAG="${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          LATEST_TAG="${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }}:latest"
          
          # Build Docker image from project root using admin app's Dockerfile
          docker build \
            --platform linux/amd64 \
            --file apps/admin/Dockerfile \
            --tag $IMAGE_TAG \
            --tag $LATEST_TAG \
            .
          
          # Push both tags
          docker push $IMAGE_TAG
          docker push $LATEST_TAG
          
          # Save image tag for deployment
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
      
      # Deploy to Cloud Run
      - name: Deploy to Cloud Run
        run: |
          gcloud run deploy ${{ env.SERVICE_NAME }} \
            --image ${{ env.IMAGE_TAG }} \
            --region ${{ env.REGION }} \
            --platform managed \
            --no-allow-unauthenticated \
            --service-account="suzumina-admin-sa@${{ env.PROJECT_ID }}.iam.gserviceaccount.com" \
            --set-env-vars="NODE_ENV=production,NEXT_TELEMETRY_DISABLED=1,GCP_PROJECT_ID=${{ env.PROJECT_ID }},NEXTAUTH_URL=https://admin.suzumina.click" \
            --set-secrets="DISCORD_CLIENT_ID=DISCORD_CLIENT_ID:latest,DISCORD_CLIENT_SECRET=DISCORD_CLIENT_SECRET:latest,NEXTAUTH_SECRET=NEXTAUTH_SECRET:latest,ADMIN_DISCORD_IDS=default-admin-discord-ids:latest" \
            --memory 512Mi \
            --cpu 1 \
            --min-instances 0 \
            --max-instances 1 \
            --timeout 300 \
            --port 3000

      # Configure admin-only access
      - name: Configure admin access
        run: |
          echo "Configuring admin-only access for Cloud Run service..."
          
          # Remove any existing public access
          gcloud run services remove-iam-policy-binding ${{ env.SERVICE_NAME }} \
            --region=${{ env.REGION }} \
            --member="allUsers" \
            --role="roles/run.invoker" \
            --quiet || echo "No public access to remove"
          
          # Add IAM policy binding for admin users only
          # Note: This requires the admin email to be stored in secrets
          if [ -n "${{ secrets.ADMIN_EMAIL }}" ]; then
            gcloud run services add-iam-policy-binding ${{ env.SERVICE_NAME }} \
              --region=${{ env.REGION }} \
              --member="user:${{ secrets.ADMIN_EMAIL }}" \
              --role="roles/run.invoker"
            echo "‚úÖ Added admin access for ${{ secrets.ADMIN_EMAIL }}"
          else
            echo "‚ö†Ô∏è  ADMIN_EMAIL secret not configured. Service will require manual IAM configuration."
          fi
          
          # Verify the policy was applied
          echo "Verifying IAM policy..."
          gcloud run services get-iam-policy ${{ env.SERVICE_NAME }} \
            --region=${{ env.REGION }} \
            --format="yaml"
      
      # Health check (admin authentication required)
      - name: Service deployment verification
        run: |
          # Get service URL
          SERVICE_URL=$(gcloud run services describe ${{ env.SERVICE_NAME }} \
            --region ${{ env.REGION }} \
            --format 'value(status.address.url)')
          
          echo "Admin service URL: $SERVICE_URL"
          
          # Wait for deployment to be ready
          echo "Waiting for deployment to be ready..."
          sleep 30
          
          # Basic connectivity check (will show 401/403 due to auth requirements)
          echo "Checking service connectivity (expect 401/403 due to admin auth)..."
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$SERVICE_URL" || echo "000")
          
          if [ "$HTTP_CODE" = "401" ] || [ "$HTTP_CODE" = "403" ]; then
            echo "‚úÖ Service deployed successfully (HTTP $HTTP_CODE - authentication required as expected)"
          elif [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Service deployed successfully (HTTP $HTTP_CODE)"
          else
            echo "‚ö†Ô∏è  Service responded with HTTP $HTTP_CODE"
            echo "This may be normal for admin-only services"
          fi
          
          echo "üéØ Admin service deployed to: $SERVICE_URL"
          echo "üîí Access is restricted to authorized admin users only"
      
      # Cleanup old images
      - name: Cleanup old images
        run: |
          echo "Checking Docker images in repository..."
          
          # Show current images for monitoring
          echo "Current admin images in repository:"
          gcloud artifacts docker images list \
            ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }} \
            --include-tags \
            --sort-by="~CREATE_TIME" \
            --format="table(IMAGE,CREATE_TIME,TAGS)" || echo "No images found or error listing"
          
          # Count total images
          IMAGE_COUNT=$(gcloud artifacts docker images list \
            ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }} \
            --format="value(IMAGE)" 2>/dev/null | wc -l || echo "0")
          
          echo "Total admin images in repository: $IMAGE_COUNT"
          
          if [ "$IMAGE_COUNT" -gt 5 ]; then
            echo "‚ö†Ô∏è  Admin repository has $IMAGE_COUNT images. Consider cleanup."
          else
            echo "‚úÖ Admin repository size is manageable ($IMAGE_COUNT images)"
          fi